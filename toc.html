<html>
<head>
  <title>OpenGL Insights</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" type="text/css" href="style.css" />

  <style type="text/css">
  dl#toc {
    width: 630;
    position: relative;
  }
  dl#toc dt,
  dl#toc dd {
    margin: 0;
    padding: 0;
  }
  dl#toc dt {
    padding: 0.2em;
    font-size: 1.4em;
    float: left;
    background-color: #eee;
    position: absolute;
    top: 0;
  }
  dl#toc dt:hover {
    cursor: pointer;
  }
  dl#toc dt span.numeral {
    color: #600;
    padding: 0 0.4em;
    font-family: serif;
  }
  dl#toc dt span.section-title {
    display: none;
  }

  dl#toc dt.selected {
    background-color: #eee;
    top: 0;
    border-top: 2px solid #ccc;
    border-left: 2px solid #ccc;
    border-right: 2px solid #ccc;
    z-index: 1;
  }
  dl#toc dt.selected span.numeral {
    font-weight: bold;
  }
  dl#toc dt.selected span.section-title {
    display: inline;
    padding-right: 0.2em;
  }

  dl#toc dd {
    display: none;
  }
  dl#toc dd.selected {
    clear: left;
    display: block;
    background-color: #eee;
    padding: 0.2em;
    position: relative;
    border: 2px solid #ccc;
  }
  dl#toc dd.selected p.desc {
    display: block;
    font-size: 0.8em;
    padding: 0 0.5em;
  }
  dl#toc dd.selected a {
    background-color: #369;
    color: #ddd;
    text-decoration: none;
    padding: 0.2em;
  }

  dl#toc dd ol {
    margin: 0;
    padding: 0;
  }
  dl#toc dd ol li {
    list-style-type: none;
    padding: 0.4em;
    margin: 0.2em;
    background-color: #ddd;
  }
  dl#toc dd ol li div.tags {
    font-style: italic;
    font-size: 0.7em;
  }
  dl#toc dd ol li div.tags span.tag {
    color: #369;
    padding: 0.2em;
  }
  dl#toc dd ol li span.author {
    font-size: 0.8em;
  }
  </style>

  <script type="text/javascript">

  var TOC = null;
  var sections = null;
  var chapters = null;

  var hideSections = function() {
    for( var jj = 0; jj < sections.length; ++jj ) {
      sections[jj].className = "";
      sections[jj].style.left = "0px";
    }
  }

  var setSectionPositions = function() {
    var x = 0;
    var y = sections[0].clientHeight;

    for( var jj = 0; jj < sections.length; ++jj ) {
      sections[jj].style.left = x + "px";
      x += sections[jj].clientWidth + 8;

      chapters[jj].style.top = y + "px";

      console.log( "section" + jj + ".width = " + sections[jj].clientWidth );
      console.log( "section" + jj + ".x = " + x );
    }
  }

  var hideChapters = function(){
    for (var jj = 0; jj < chapters.length; ++jj) {
      chapters[jj].className = "";
    };
  }

  document.addEventListener( "DOMContentLoaded", function( e ) {
    TOC = document.getElementById( "toc" );
    sections = TOC.getElementsByTagName( "dt" );
    chapters = TOC.getElementsByTagName( "dd" );

    setSectionPositions();

    for (var ii = 0; ii < sections.length; ++ii) {
      sections[ii].addEventListener( "click", function( e ) { 
        hideSections();
        hideChapters();

        e.currentTarget.className = "selected";
        e.currentTarget.nextElementSibling.className = "selected";
        e.currentTarget.nextElementSibling.style.top = e.currentTarget.clientHeight + "px";

        setSectionPositions();
      }, false );
    };

  }, false );

  </script>

</head>    

<body>

  <a href="index.html"><img src="images/strip.png" width="639" height="140" alt="OpenGL Insights" /></a>
  <table summary="" border="0" width="630">
    <tr align="center" class="sitemap">
      <td><a href="cover.html">Cover</a></td>
      <td><a href="toc.html">Table of Contents</a></td>
      <td><a href="pipeline.html">Pipeline Map</a></td>
      <td><a href="tips.html">OpenGL Tips</a></td>
      <td><a href="contributors.html">Contributors</a></td>
      <td><a href="reviews.html">Reviews</a></td>
      <td><a href="code.html">Code</a></td>
<!--
  <td><a href="figures.html">Figures</a></td>
  <td><a href="bibliography.html">Bibliography</a></td>
-->  
<td><a href="bibtex.html">BibTeX</a></td>
<td><a href="errata.html">Errata</a></td>
<td><a href="http://blog.openglinsights.com/">Blog</a></td>
</tr>
</table>

<h1>Table of Contents</h1>

<dl id="toc">
  <dt class="selected" title="Discovering">
    <span class="numeral">I</span><span class="section-title"> Discovering</span>
  </dt>
  <dd class="selected">
    <p class="desc">
      In this section, we discover many facets of OpenGL: teaching modern OpenGL in academia; using OpenGL on the web with WebGL; tessellation shaders in OpenGL 4.0; procedural textures; the safety critical variant, OpenGL SC; and multi-GPU OpenGL and CUDA interop.<br />
      <br/>
      OpenGL enjoys widespread use in computer graphics courses around the world. Now-depreciated OpenGL features such as fixed-function lighting, immediate mode, and built-in transforms made the barrier to entry low. However, modern OpenGL has removed many of these features, resulting in a lean API that exposes the functionality of the underlying hardware. Academia has taken these changes in stride, updating their graphics courses to modern OpenGL. In Chapter 1, "Teaching Computer Graphics Starting With Shader-Based OpenGL," Edward Angel discusses how an introductory computer graphics course can be taught using modern OpenGL. In Chapter 2, "Transitioning Students to Post-Deprecation OpenGL," Mike Bailey presents C++ abstractions and GLSL naming conventions to bridge the gap between depreciated and modern OpenGL for use in course assignments.<br />
      <br />
      When we announced our call for authors for OpenGL Insights in May 2011, we included WebGL as a desired topic. Since then, WebGL has gained such traction that an entire book could easily be justified. In Chapter 3, "WebGL for OpenGL Developers," Patrick Cozzi and Scott Hunter present WebGL for those who already know OpenGL. In the following chapter, "Porting Mobile Apps to WebGL," Ashraf Samy Hegab shows the benefits, differences, and trade-offs of using WebGL for mobile applications. Several chapters in later sections continue our WebGL exploration.<br />
      <br />
      Christophe Riccio takes a rigorous look at communication between the OpenGL API and GLSL and different shader stages in Chapter 5, "The GLSL Shader Interfaces." He carefully examines using varying blocks; attribute, varying, and fragment output variable locations; linked and separated programs; using semantics in our designs; and more.<br />
      <br />
      Today, one of the differences between movie-quality rendering and real-time rendering is geometric complexity; movies generally have much higher geometric detail. To improve geometric detail in real-time rendering, tessellation can be done in hardware. Although this has been available on ATI cards since the ATI Radeon 8500 in 2001, tessellation shaders were recently standardized and made part of OpenGL 4.0. In Chapter 6, "An Introduction to Tessellation Shaders," Philip Rideout and Dirk Van Gelder introduce the new fixed and programmable tessellation stages.<br />
      <br />
      As the gap between compute power and memory bandwidth continues to widen, procedural techniques become increasingly important. Small size is speed. Procedural textures not only have trivial memory requirements, but can also have excellent visual quality, allowing for analytic derivatives and anisotropic antialiasing. Stefan Gustavson introduces procedural textures, including antialiasing and using Perlin and Worley noise in Chapter 7, "Procedural Textures in GLSL." Best of all, he provides GLSL noise functions for OpenGL, OpenGL ES, and WebGL.<br />
      <br />
      OpenGL SC, for safety critical, may be one of the lesser-known OpenGL variants. In Chapter 8, "OpenGL SC Emulation Based on OpenGL and OpenGL ES," Hwanyong Lee and Nakhoon Baek explain the motivation for OpenGL SC and describe the benefits of implementing it based on other OpenGL variants, instead of creating custom drivers or a software implementation.<br />
      <br />
      In the past 15 years, consumer GPUs have transformed from dedicated fixed-function graphics processors to general-purpose massively-parallel processors. Technologies like CUDA and OpenCL have emerged for developing general data-parallel algorithms on the GPU. There is, of course, a need for these general algorithms, like particle systems and physical simulation, to interop efficiently with OpenGL for rendering. In the final chapter of this section, "Mixing Graphics and Compute with Multiple GPUs," Alina Alt reviews interoperability between CUDA and OpenGL and presents interoperability between multiple GPUs where one GPU is used for CUDA and another for OpenGL.    
    </p>
    <ol class="start">
      <li>
        Teaching Computer Graphics Starting with Shader-Based OpenGL<br />
        <span class="author">Edward Angel</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
      <li>
        Transitioning Students to Post-Deprecation OpenGL<br />
        <span class="author">Mike Bailey</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
      <li>
        WebGL for OpenGL Developers<br />
        <span class="author">Patrick Cozzi and Scott Hunter</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>, <span class="tag">WebGL</span>
        </div>
      </li>
      <li>
        Porting Mobile Apps to WebGL<br />
        <span class="author">Ashraf Samy Hegab</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">WebGL</span>, <span class="tag">OpenGL ES</span>
        </div>
      </li>
      <li>
        The GLSL Shader Interfaces<br />
        <span class="author">Christophe Riccio</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
      <li>
        An Introduction to Tessellation Shaders<br />
        <span class="author">Philip Rideout and Dirk Van Gelder</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
      <li>
        Procedural Textures in GLSL<br />
        <span class="author">Stefan Gustavson</span><br />
        <br />
        <a href="http://webstaff.itn.liu.se/~stegu/OpenGLinsights/shadertutorial.html">demo</a><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>, <span class="tag">WebGL</span>, <span class="tag">OpenGL ES</span>
        </div>
      </li>
      <li>
        OpenGL SC Emulation Based on OpenGL and OpenGL ES<br />
        <span class="author">Hwanyong Lee and Nakhoon Baek</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>, <span class="tag">OpenGL ES</span>, <span class="tag">OpenGL SC</span>
        </div>
      </li>
      <li>
        Mixing Graphics and Compute with Multiple GPUs<br />
        <span class="author">Alina Alt</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
    </ol>
  </dd>
  <dt title="Rendering Techniques">
    <span class="numeral">II</span><span class="section-title"> Rendering Techniques</span>
  </dt>
  <dd>
    <p class="desc">
      We can’t possibly imagine a book about OpenGL without rendering, and neither could the authors of this book.<br />
      <br />
      António Ramires Fernandes and Bruno Oliveira provide a use case for the new OpenGL 4 tessellation pipeline through terrain rendering in their chapter "GPU Tessellation: We Still Have a LOD of Terrain to Cover," providing an entirely GPU-based method for continuous level of detail maintaining a high level of fidelity to the original mesh.<br />
      <br />
      Sébastien Hillaire brings us to a parallel universe where rendering is defined by lines in his chapter "Antialiased Volumetric Lines Using Shader-Based Extrusion." He comes back on the line primitives exposed by OpenGL and their issues before bringing perspective to line rendering thanks to two approaches: one based on the vertex shader stage and one based on the geometry shader stage for perspective correct and antialiased lines.<br />
      <br />
      Stefan Gustavson leads us close to new borders through his chapter "2D Shape Rendering by Distance Fields," allowing perfectly antialiased contours. He is pushing his concept to font rendering and distance field-based effects.<br />
      <br />
      Benjamin Encz analyses WebGL font rendering in his chapter "Efficient Text Rendering in WebGL" by describing canvas and bitmap-based methods. He concludes his chapter with a performance analysis with both the frame rate and the memory footprint in mind.<br />
      <br />
      Dzmitry Malyshau discusses an approach inspired by Blender in his chapter "Layered Textures Rendering Pipeline." He aims at providing more flexibility to the rendering pipeline to handle complex object materials so that artists may express their creativity during the producing while maintaining real-time performance.<br />
      <br />
      Charles de Rousiers and Matt Pettineo present a method for "Depth of Field with Bokeh Rendering." Their method, developed around OpenGL 4 hardware atomic counter, image load and store, and indirect draw, provides a level of performance for real-time application.<br />
      <br />
      Finally, Jochem van der Spek introduces a technique he calls "Shadow Proxies," which provides, for appropriate scenarios, real-time soft shadows with color bleeding.
    </p>
    <ol>
      <li>
        GPU Tessellation: We Still have a LOD of Terrain to Cover<br />
        <span class="author">António Ramires Fernandes and Bruno Oliveira</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
      <li>
        Antialiased Volumetric Lines Using Shader-Based Extrusion<br />
        <span class="author">Sébastien Hillaire</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>, <span class="tag">WebGL</span>, <span class="tag">OpenGL ES</span>
        </div>
      </li>
      <li>
        2D Shape Rendering by Distance Fields<br />
        <span class="author">Stefan Gustavson</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>, <span class="tag">WebGL</span>, <span class="tag">OpenGL ES</span>
        </div>
      </li>
      <li>
        Efficient Text Rendering in WebGL<br />
        <span class="author">Benjamin Encz</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">WebGL</span>
        </div>
      </li>
      <li>
        Layered Textures Rendering Pipeline<br />
        <span class="author">Dzmitry Malyshau</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
      <li>
        Depth of Field with Bokeh Rendering<br />
        <span class="author">Charles de Rousiers and Matt Pettineo</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
      <li>
        Shadow Proxies<br />
        <span class="author">Jochem van der Spek</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
    </ol>
  </dd>
  <dt title="Bending the Pipeline">
    <span class="numeral">III</span><span class="section-title"> Bending the Pipeline</span>
  </dt>
  <dd>
    <p class="desc">
      Today GPUs are masters of performance, considering either high-end desktop GPUs or even mobile GPUs, which deliver an unbelievable amount of graphics relative to the power consumption. The future of graphics raises a lot of question regarding how to scale performance, doing more with less. Based on research on petascale and exoscale supercomputers, we notice that such a scale of performance forces us to reconsider memory, bandwidth, and data movement. Challenges are ahead for GPU innovations. Under the name "bending the pipeline," we include all ideas that push the graphics pipeline to explore alternative ways to feed the rendering pipeline.<br />
      <br />
      We start with two classic techniques. The first one, "Real-Time Physically-Based Deformation Using Transform Feedback," presented by Muhammad Mobeen Movania and Lin Feng, explores the OpenGL transform feedback for GPU-based physical simulation. The second technique, "Hierarchical Depth-Culling and Bounding-Box Management on GPU," presented by Dzmitry Malyshau, presents a method based on the depth buffer and bounding boxes to discard invisible objects before the actual rendering even starts.<br />
      <br />
      Maybe shadow mapping is a way to bend the pipeline, but Daniel Rákos certainly pushes it further in his chapter "Massive Number of Shadows with Layered Rendering" with a rendering method allowing him to generate multiple shadow maps per draw call thanks to layered rendering.<br />
      <br />
      In their chapter "Efficient Layered Fragment Buffer Techniques," Pyarelal Knowles, Geoff Leach, and Fabio Zambetta lead us to explore one of the most interesting innovations of OpenGL 4 hardware, image load store, and atomic operations, through an example of order-independent transparency with a special highlight of performance resulting from different approaches.<br />
      <br />
      One step further into innovation, Daniel Rákos introduces "Programmable Vertex Pulling," a radical change of perspective, where we don’t submit work to the GPU, but let the GPU query the work. No doubt this approach will evolve and gain a lot of importance in the years to come.<br />
      <br />
      If pushing the boundaries of today’s graphics requires a shift in paradigm, bringing new asset representations might be an answer. This is the direction of the work on Gigavoxels of Cyril Crassin and Simon Green. For their OpenGL Insights chapter "Octree-Based Sparse Voxelization Using the GPU," they explain how a GPU may be efficiently used to build voxel-based representation.
    </p>
    <ol>
      <li>
        Real-Time Physically Based Deformation Using Transform Feedback<br />
        <span class="author">Muhammad Mobeen Movania and Lin Feng</span><br />
        <br />
        <a href="http://code.google.com/p/opencloth/">opencloth</a><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
      <li>
        Hierarchical Depth Culling and Bounding-Box Management on the GPU<br />
        <span class="author">Dzmitry Malyshau</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
      <li>
        Massive Number of Shadow-Casting Lights with Layered Rendering<br />
        <span class="author">Daniel Rákos</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
      <li>
        Efficient Layered Fragment Buffer Techniques<br />
        <span class="author">Pyarelal Knowles, Geoff Leach, and Fabio Zambetta</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
      <li>
        Programmable Vertex Pulling<br />
        <span class="author">Daniel Rákos</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
      <li>
        Octree-Based Sparse Voxelization Using the GPU Hardware Rasterizer<br />
        <span class="author">Cyril Crassin and Simon Green</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
    </ol>
  </dd>
  <dt title="Performance">
    <span class="numeral">IV</span><span class="section-title"> Performance</span>
  </dt>
  <dd>
    <p class="desc">
      When it comes to real-time graphics, performance is what defines the possible from the impossible; it is what sets the boundaries.<br />
      <br />
      A lack of performance might come from a lack of understanding of the platform we are working on. This may have a dramatic negative impact on the tile-based GPUs leading the OpenGL ES world. In his chapter, "Performance Tuning for TileBased Architectures," Bruce Merry presents key tile-based GPU architecture features and how to take advantage of them. Jon McCaffrey follows this discussion in his chapter "Exploring Mobile vs. Desktop OpenGL Performance," which shows the performance-scale differences between the mobile and desktop worlds.<br />
      <br />
      Performance is not only the concern of GPU architectures, it is also the direct result of how we write software. With GPUs whose performances increase at a faster rate than CPUs, we are more and more often CPU-bound, leaving us incapable to benefit from all the GPU power. Sébastien Hillaire, in his chapter "Improving Performance by Reducing Calls to the Drivers," introduces some fundamental concepts to reduce CPU overhead with a legacy flavor.<br />
      <br />
      In his chapter "Indexing Multiple Vertex Arrays," Arnaud Masserann comes back to one of the most fundamental elements for GPU performance: how we submit vertex array data to the GPU. He provides a directly applicable method to ensure that vertex indexing will be used even on assets not organized this way, like COLLADA geometry.<br />
      <br />
      Finally, sometimes we are left with no choice: to scale performance, we must scale the number of GPUs used for rendering. This is the topic of Shalini Venkataraman in her chapter "Multi-GPU Rendering on NVIDIA Quadro." She explains how to efficiently use multiple GPUs for rendering and integrate their work to build the final image.
    </p>
    <ol>
      <li>
        Performance Tuning for Tile-Based Architectures<br />
        <span class="author">Bruce Merry</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">WebGL</span>, <span class="tag">OpenGL ES</span>
        </div>
      </li>
      <li>
        Exploring Mobile vs. Desktop OpenGL Performance<br />
        <span class="author">Jon McCaffrey</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>, <span class="tag">WebGL</span>, <span class="tag">OpenGL ES</span>
        </div>
      </li>
      <li>
        Improving Performance by Reducing Calls to the Driver<br />
        <span class="author">Sébastien Hillaire</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
      <li>
        Indexing Multiple Vertex Arrays<br />
        <span class="author">Arnaud Masserann</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>, <span class="tag">WebGL</span>, <span class="tag">OpenGL ES</span>
        </div>
      </li>
      <li>
        Multi-GPU Rendering on NVIDIA Quadro<br />
        <span class="author">Shalini Venkataraman</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
    </ol>
  </dd>
  <dt title="Transfers">
    <span class="numeral">V</span><span class="section-title"> Transfers</span>
  </dt>
  <dd>
    <p class="desc">
      OpenGL applications transfer a lot of data. Data is transferred between machines, between disk and system memory, between system and video memory, between video memory and video memory, and so on. Optimizing these transfers improves performance. In this section, we look at optimizing asynchronous transfers between the CPU and GPU; compressing models for use with WebGL; compressing textures on the GPU for video creation; and an efficient geometry file format.<br />
      <br />
      Although general computations like particle systems are being pushed to the GPU, there is still a need to do many computations or IO on the CPU and then efficiently stream data to the GPU. In Chapter 28, "Asynchronous Buffer Transfers," Ladislav Hrabcak and Arnaud Masserann share best practices for maximizing performance when using buffer objects to transfer data between the CPU and GPU in either direction. With detailed performance analysis, they cover direct memory access (DMA), buffer usage hints, implicit synchronization with draw calls, pinned memory, and multithreading. Shalini Venkataraman continues the asynchronous transfers discussion in the following chapter, "Fermi Asynchronous Texture Transfers," where she discusses how the NVIDIA Fermi architecture allows transfer and rendering to occur at the same time when using multiple threads and OpenGL contexts.<br />
      <br />
      The discussion of transfers moves from within a system to across systems in Chapter 30, "WebGL Models: End-to-End." Won Chun presents the techniques, including a detailed analysis, used in Google Body to compress and transfer models to a web browser for rendering with WebGL. Continuing on the compression theme, Brano Kemen demonstrates real-time image compression on the GPU in Chapter 31, "In-Game Video Capture with Real-Time Texture Compression." He applies his method to video compression using a DXT fixed-rate compression format to reduce bandwidth consumption, and he explores various decoloration methods to enhance image compression quality.<br />
      <br />
      In graphics, content is king. A smooth content-creation pipeline empowers artists, and a format that requires minimal runtime processing improves load times. In the last chapter of this section, "An OpenGL Friendly Geometry File Format and its Maya Exporter," Adrien Herubel and Venceslas Biri present the Drone format, a binary geometry file format suitable for use with OpenGL.
    </p>
    <ol>
      <li>
        Asynchronous Buffer Transfers<br />
        <span class="author">Ladislav Hrabcak and Arnaud Masserann</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
      <li>
        Fermi Asynchronous Texture Transfers<br />
        <span class="author">Shalini Venkataraman</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
      <li>
        WebGL Models: End-to-End<br />
        <span class="author">Won Chun</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">WebGL</span>
        </div>
      </li>
      <li>
        In-Game Video Capture with Real-Time Texture Compression<br />
        <span class="author">Brano Kemen</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
      <li>
        An OpenGL-Friendly Geometry File Format and Its Maya Exporter<br />
        <span class="author">Adrien Herubel and Venceslas Biri</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>, <span class="tag">OpenGL ES</span>
        </div>
      </li>
      <li></li>
      <li></li>
    </ol>
  </dd>
  <dt title="Debugging and Profiling">
    <span class="numeral">VI</span><span class="section-title"> Debugging and Profiling</span>
  </dt>
  <dd>
    <p class="desc">
      We probably often underestimate how powerful the OpenGL API can be. However, programming is less about the result than the process to reach this result. The most impressive rendering is nothing but the end of a path that is, in a large part, debugging and profiling. Unfortunately, OpenGL doesn’t have a great reputation on that side. Who really enjoys using glGetError?<br />
      <br />
      This part of the OpenGL experience is now history since the release at SIGGRAPH 2010 of the GL ARB debug ouput extension that revolutionizes every day of an OpenGL programmer’s life. This revolution is captured by António Ramires and Bruno Oliveira in their chapter "ARB_debug_output: OpenGL’s Solutions for Desperate Developers," which shows every aspect of this extension, how to break the program when an OpenGL error occurs, and even opens on interesting debugging perspectives.<br />
      <br />
      Profiling knew an earlier take-off in the world of OpenGL programming thanks to the release of GL_EXT_timer_query in 2006, then standardized within OpenGL 3.3. Thanks to Christopher Lux and his chapter, "The OpenGL Timer Query," this primitive of OpenGL profiling won’t hide any secrets any longer.<br />
      <br />
      There are two kinds of profiler: the built-in and the external tools, which provide two different approaches to picture profiling. On one side, a profiler tightly connected to application designs and specific use-cases, on other side more generic tools that can embrace all sorts of scenarios and software. The first approach is perfectly reflected by Lionel Fuentes in his chapter "A Real-Time Profiling Tool," which deals with how a built-in real-time profiler can help the game programmer and also the artist creating game assets. Chris Dirks and Omar A. Rodriguez expose the second approach through their chapter "Browser Graphics Analysis and Optimizations," which discuss the utilization of Intel GPA to study WebGL performance.<br />
      <br />
      Finally, Aleksandar Dimitrijević offers us two innovative profiling chapters, first introducing us to GPU P-States in his chapter "Performance State Tracking," where he calls our attention to how GPUs reach full speed and how this may affect our performance measurements. He backs his discussion with AMD and NVIDIA proprietary libraries. In his second chapter, he deals with the problem of GPU memory limits. OpenGL doesn’t provide functionalities to determine the actual memory usage, but proprietary extensions provide the required information, and Dimitrijević helps us to go through them in his chapter "Monitoring Graphics Memory Usage."
    </p>
    <ol>
      <li>
        ARB_debug_output: A Helping Hand for Desperate Developers<br />
        <span class="author">António Ramires Fernandes and Bruno Oliveira</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
      <li>
        The OpenGL Timer Query<br />
        <span class="author">Christopher Lux</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
      <li>
        A Real-Time Profiling Tool<br />
        <span class="author">Lionel Fuentes</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
      <li>
        Browser Graphics Analysis and Optimizations<br />
        <span class="author">Chris Dirks and Omar A. Rodriguez</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">WebGL</span>
        </div>
      </li>
      <li>
        Performance State Tracking<br />
        <span class="author">Aleksandar Dimitrijević</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
      <li>
        Monitoring Graphics Memory Usage<br />
        <span class="author">Aleksandar Dimitrijević</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>
        </div>
      </li>
    </ol>
  </dd>
  <dt title="Software Design">
    <span class="numeral">VII</span><span class="section-title"> Software Design</span>
  </dt>
  <dd>
    <p class="desc">
      Developers work with OpenGL at many levels of the software stack. Some developers create OpenGL implementations by writing drivers or, as we will see, using another graphics API; other developers create middleware or engines that simplify the use of OpenGL and raise the level of abstraction; and perhaps the majority of OpenGL developers create actual applications, whether by directly calling OpenGL or by using OpenGL-based engines. In this section, we look at software design at each layer of this stack. We consider implementing OpenGL ES 2.0, engines and applications built on WebGL, making legacy OpenGL code modern, and building cross-platform OpenGL applications.<br />
      <br />
      ANGLE, or the Almost Native Graphics Layer Engine, provides an OpenGL ES 2.0 implementation using Direct3D 9. It is used as the default WebGL backend for Chrome and Firefox on Windows. Implementing ANGLE is not nearly as simple as converting OpenGL calls to Direct3D calls; the differences in capabilities of the APIs need to be taken into account. In Chapter 39, "The ANGLE Project: Implementing OpenGL ES 2.0 on Direct3D," Daniel Koch and Nicolas Capens discuss the implementation challenges in ANGLE, provide performance results, and suggest recommended practices.<br />
      <br />
      Given how low-level WebGL is compared to other web APIs, it was clear from its start that there would be demand for higher-level 3D engines built on WebGL. Here, we look at two such engines. SceneJS is an open-source 3D engine, based on a scene graph optimized for rendering large numbers of individually pickable and articulated objects. In Chapter 40, "SceneJS: A WebGL-Based Scene Graph Engine," Lindsay Kay presents SceneJS’ architecture and how it makes efficient use of JavaScript and WebGL.<br />
      <br />
      SpiderGL is another 3D graphics library that uses WebGL. Instead of providing higher-level constructs like a scene graph, SpiderGL provides utilities, data structures, and algorithms to simplify WebGL development but still allows the use of other WebGL code in the same application. In Chapter 41, "Features and Design Choices in SpiderGL," Marco Di Benedetto, Fabio Ganovelli, and Francesco Banterle discuss some design and implementation decisions in SpiderGL including its model representation and allowing seamless interoperability with naive WebGL calls.<br />
      <br />
      WebGL is enabling a whole new class of applications. In Chapter 42, "Multimodal Interactive Simulations on the Web," Tansel Halic, Woojin Ahn, and Suvranu De present a framework for visualization, simulation, and hardware integration for multimodal interactive simulations using WebGL. Think practicing surgical procedures using a web browser!<br />
      <br />
      Maintaining legacy and modern OpenGL code in the same code base can prove challenging. Jesse Barker and Alexandros Frantzis share their experiences in Chapter 43, "A Subset Approach to Using OpenGL and OpenGL ES." They suggest ways to move to a single modern code base written against both OpenGL and OpenGL ES.<br />
      <br />
      In "The Build Syndrome," the final chapter of this section and of the book, Jochem van der Spek and Daniel Dekkers discuss in detail building cross-platform OpenGL applications with C++/Objective-C and CMake.
    </p>
    <ol>
      <li>
        The ANGLE Project: Implementing OpenGL ES 2.0 on Direct3D<br />
        <span class="author">Daniel Koch and Nicolas Capens</span><br />
        <br />
        <a href="http://code.google.com/p/angleproject/">project page</a><br />
        <br />
        <div class="tags">
          tags: <span class="tag">WebGL</span>, <span class="tag">OpenGL ES</span>
        </div>
      </li>
      <li>
        SceneJS: A WebGL-Based Scene Graph Engine<br />
        <span class="author">Lindsay Kay</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">WebGL</span>
        </div>
      </li>
      <li>
        Features WebGL and Design Choices in SpiderGL<br />
        <span class="author">Marco Di Benedetto, Fabio Ganovelli, and Francesco Banterle</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">WebGL</span>
        </div>
      </li>
      <li>
        Multimodal Interactive Simulations on the Web<br />
        <span class="author">Tansel Halic, Woojin Ahn, and Suvranu De</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">WebGL</span>
        </div>
      </li>
      <li>
      <li>
        A Subset Approach to Using OpenGL and OpenGL ES<br />
        <span class="author">Jesse Barker and Alexandros Frantzis</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>, <span class="tag">OpenGL ES</span>
        </div>
      </li>
      <li>
      <li>
        The Build Syndrome<br />
        <span class="author">Jochem van der Spek and Daniel Dekkers</span><br />
        <br />
        <div class="tags">
          tags: <span class="tag">OpenGL</span>, <span class="tag">OpenGL ES</span>
        </div>
      </li>
      <li>
    </ol>
  </dd>
</dl>

</body>
</html>