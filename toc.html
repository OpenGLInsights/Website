<html>
<head>
  <title>OpenGL Insights</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" type="text/css" href="style.css" />

  <style type="text/css">
  dl#full-toc {
    width: 630px;
  }
  </style>
</head>    

<body>

  <a href="index.html"><img src="images/strip.png" width="639" height="140" alt="OpenGL Insights" /></a>
  <table summary="" border="0" width="630">
    <tr align="center" class="sitemap">
      <td><a href="cover.html">Cover</a></td>
      <td><a href="toc.html">Table of Contents</a></td>
      <td><a href="pipeline.html">Pipeline Map</a></td>
      <td><a href="tips.html">OpenGL Tips</a></td>
      <td><a href="contributors.html">Contributors</a></td>
      <td><a href="reviews.html">Reviews</a></td>
      <td><a href="code.html">Code</a></td>
<!--
  <td><a href="figures.html">Figures</a></td>
  <td><a href="bibliography.html">Bibliography</a></td>
-->  
<td><a href="bibtex.html">BibTeX</a></td>
<td><a href="errata.html">Errata</a></td>
<td><a href="http://blog.openglinsights.com/">Blog</a></td>
</tr>
</table>

<h1>Table of Contents</h1>

<table summary="" border="0" width="639">

  <tr class="spaceUnder">
    <td colspan="2">
      To the right of each chapter, a combination of <span class="tipsAPI">OpenGL</span>, <span class="tipsAPI">WebGL</span>, <span class="tipsAPI">OpenGL ES</span>, and <span class="tipsAPI">OpenGL SC</span> tags identify what APIs the chapter is most relevant to.
    </td>
  </tr>

  <tr class="spaceUnder">
    <td colspan="2" class="sectionName">
      I Discovering
      <p>
        In this section, we discover many facets of OpenGL: teaching modern OpenGL in academia; using OpenGL on the web with WebGL; tessellation shaders in OpenGL 4.0; procedural textures; the safety critical variant, OpenGL SC; and multi-GPU OpenGL and CUDA interop.
      </p>
    </td>
  </tr>

  <tr class="spaceUnder">
    <td>
      1. <em>Teaching Computer Graphics Starting with Shader-Based OpenGL</em>
      <br />
      Edward Angel
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      2. <em>Transitioning Students to Post-Deprecation OpenGL</em>
      <br />
      Mike Bailey
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      3. <em>WebGL for OpenGL Developers</em>
      <br />
      Patrick Cozzi and Scott Hunter
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL<br />WebGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      4. <em>Porting Mobile Apps to WebGL</em>
      <br />
      Ashraf Samy Hegab
    </td>
    <td width="15%" align="right" class="tipsAPI">WebGL<br />OpenGL ES</td>
  </tr>

  <tr class="spaceUnder">
    <td>
      5. <em>The GLSL Shader Interfaces</em>
      <br />
      Christophe Riccio
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr>

  <tr class="spaceUnder">
    <td>
      6. <em>An Introduction to Tessellation Shaders</em>
      <br />
      Philip Rideout and Dirk Van Gelder
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      7. <em>Procedural Textures in GLSL [<a href="http://webstaff.itn.liu.se/~stegu/OpenGLinsights/shadertutorial.html" target="_blank">demo</a>]</em>
      <br />
      Stefan Gustavson
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL<br />WebGL<br />OpenGL ES</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      8. <em>OpenGL SC Emulation Based on OpenGL and OpenGL ES</em>
      <br />
      Hwanyong Lee and Nakhoon Baek
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL<br />OpenGL ES<br />OpenGL SC</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      9. <em>Mixing Graphics and Compute with Multiple GPUs</em>
      <br />
      Alina Alt
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td colspan="2" class="sectionName">
      II Rendering Techniques

      <p>
        We can’t possibly imagine a book about OpenGL without rendering, and neither could the authors of this book.
      </p>
    </td>
  </tr>

  <tr class="spaceUnder">
    <td>
      10. <em>GPU Tessellation: We Still Have a LOD of Terrain to Cover</em>
      <br />
      António Ramires Fernandes and Bruno Oliveira
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      11. <em>Antialiased Volumetric Lines Using Shader-Based Extrusion</em>
      <br />
      S&#233;bastien Hillaire
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL<br />WebGL<br />OpenGL ES</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      12. <em>2D Shape Rendering by Distance Fields</em>
      <br />
      Stefan Gustavson
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL<br />WebGL<br />OpenGL ES</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      13. <em>Efficient Text Rendering in WebGL</em>
      <br />
      Benjamin Encz
    </td>
    <td width="15%" align="right" class="tipsAPI">WebGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      14. <em>Layered Textures Rendering Pipeline</em>
      <br />
      Dzmitry Malyshau
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      15. <em>Depth of Field with Bokeh Rendering</em>
      <br />
      Charles de Rousiers and Matt Pettineo
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr>

  <tr class="spaceUnder">
    <td>
      16. <em>Shadow Proxies</em>
      <br />
      Jochem van der Spek
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td colspan="2" class="sectionName">
      III Bending the Pipeline

      <p>
        Today GPUs are masters of performance, considering either high-end desktop GPUs or even mobile GPUs, which deliver an unbelievable amount of graphics relative to the power consumption. The future of graphics raises a lot of question regarding how to scale performance, doing more with less. Based on research on petascale and exoscale supercomputers, we notice that such a scale of performance forces us to reconsider memory, bandwidth, and data movement. Challenges are ahead for GPU innovations. Under the name “bending the pipeline,” we include all ideas that push the graphics pipeline to explore alternative ways to feed the rendering pipeline.
      </p>
    </td>
  </tr>

  <tr class="spaceUnder">
    <td>
      17. <em>Real-Time Physically Based Deformation Using Transform Feedback</em>
      <br />
      Muhammad Mobeen Movania and Lin Feng
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      18. <em>Hierarchical Depth Culling and Bounding-Box Management on the GPU</em>
      <br />
      Dzmitry Malyshau
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      19. <em>Massive Number of Shadow-Casting Lights with Layered Rendering</em>
      <br />
      Daniel R&aacute;kos
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      20. <em>Efficient Layered Fragment Buffer Techniques</em>
      <br />
      Pyarelal Knowles, Geoff Leach, and Fabio Zambetta
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr>

  <tr class="spaceUnder">
    <td>
      21. <em>Programmable Vertex Pulling</em>
      <br />
      Daniel R&aacute;kos
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr>

  <tr class="spaceUnder">
    <td>
      22. <em>Octree-Based Sparse Voxelization Using the GPU Hardware Rasterizer</em>
      <br />
      Cyril Crassin and Simon Green
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td colspan="2" class="sectionName">
      IV Performance

      <p>
        When it comes to real-time graphics, performance is what defines the possible from the impossible; it is what sets the boundaries.
        A lack of performance might come from a lack of understanding of the platform we are working on. This may have a dramatic negative impact on the tile-based GPUs leading the OpenGL ES world.
      </p>
    </td>
  </tr>

  <tr class="spaceUnder">
    <td>
      23. <em>Performance Tuning for Tile-Based Architectures</em>
      <br />
      Bruce Merry
    </td>
    <td width="15%" align="right" class="tipsAPI">WebGL<br />OpenGL ES</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      24. <em>Exploring Mobile vs. Desktop OpenGL Performance</em>
      <br />
      Jon McCaffrey
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL<br />WebGL<br />OpenGL ES</td>
  </tr>

  <tr class="spaceUnder">
    <td>
      25. <em>Improving Performance by Reducing Calls to the Driver</em>
      <br />
      S&#233;bastien Hillaire
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      26. <em>Indexing Multiple Vertex Arrays</em>
      <br />
      Arnaud Masserann
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL<br />WebGL<br />OpenGL ES</td>
  </tr>

  <tr class="spaceUnder">
    <td>
      27. <em>Multi-GPU Rendering on NVIDIA Quadro</em>
      <br />
      Shalini Venkataraman
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr>

  <tr class="spaceUnder">
    <td colspan="2" class="sectionName">
      V Transfers

      <p>
        OpenGL applications transfer a lot of data. Data is transferred between machines, between disk and system memory, between system and video memory, between video memory and video memory, and so on. Optimizing these transfers improves performance. In this section, we look at optimizing asynchronous transfers between the CPU and GPU; compressing models for use with WebGL; compressing textures on the GPU for video creation; and an efficient geometry file format.
        Although general computations like particle systems are being pushed to the GPU, there is still a need to do many computations or IO on the CPU and then efficiently stream data to the GPU. 
      </p>
    </td>
  </tr>

  <tr class="spaceUnder">
    <td>
      28. <em>Asynchronous Buffer Transfers</em>
      <br />
      Ladislav Hrabcak and Arnaud Masserann
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr>

  <tr class="spaceUnder">
    <td>
      29. <em>Fermi Asynchronous Texture Transfers</em>
      <br />
      Shalini Venkataraman
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      30. <em>WebGL Models: End-to-End</em>
      <br />
      Won Chun
    </td>
    <td width="15%" align="right" class="tipsAPI">WebGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      31. <em>In-Game Video Capture with Real-Time Texture Compression</em>
      <br />
      Brano Kemen
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr>

  <tr class="spaceUnder">
    <td>
      32. <em>An OpenGL-Friendly Geometry File Format and Its Maya Exporter</em>
      <br />
      Adrien Herubel and Venceslas Biri
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL<br />OpenGL ES</td>
  </tr>

  <tr class="spaceUnder">
    <td colspan="2" class="sectionName">
      VI Debugging and Profiling

      <p>
        We probably often underestimate how powerful the OpenGL API can be. However, programming is less about the result than the process to reach this result. The most impressive rendering is nothing but the end of a path that is, in a large part, debugging and profiling. Unfortunately, OpenGL doesn’t have a great reputation on that side. Who really enjoys using glGetError?
      </p>
    </td>
  </tr>

  <tr class="spaceUnder">
    <td>
      33. <em>ARB_debug_output: A Helping Hand for Desperate Developers</em>
      <br />
      António Ramires Fernandes and Bruno Oliveira
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      34. <em>The OpenGL Timer Query</em>
      <br />
      Christopher Lux
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      35. <em>A Real-Time Profiling Tool</em>
      <br />
      Lionel Fuentes
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr>

  <tr class="spaceUnder">
    <td>
      36. <em>Browser Graphics Analysis and Optimizations</em>
      <br />
      Chris Dirks and Omar A. Rodriguez
    </td>
    <td width="15%" align="right" class="tipsAPI">WebGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      37. <em>Performance State Tracking</em>
      <br />
      Aleksandar Dimitrijević
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      38. <em>Monitoring Graphics Memory Usage</em>
      <br />
      Aleksandar Dimitrijević
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td colspan="2" class="sectionName">
      VII Software Design

      <p>
        Developers work with OpenGL at many levels of the software stack. Some developers create OpenGL implementations by writing drivers or, as we will see, using another graphics API; other developers create middleware or engines that simplify the use of OpenGL and raise the level of abstraction; and perhaps the majority of OpenGL developers create actual applications, whether by directly calling OpenGL or by using OpenGL-based engines. In this section, we look at software design at each layer of this stack. We consider implementing OpenGL ES 2.0, engines and applications built on WebGL, making legacy OpenGL code modern, and building cross-platform OpenGL applications.
      </p>
    </td>
  </tr>

  <tr class="spaceUnder">
    <td>
      39. <em>The ANGLE Project: Implementing OpenGL ES 2.0 on Direct3D</em>
      <br />
      Daniel Koch and Nicolas Capens
    </td>
    <td width="15%" align="right" class="tipsAPI">WebGL<br />OpenGL ES</td>
  </tr>

  <tr class="spaceUnder">
    <td>
      40. <em>SceneJS: A WebGL-Based Scene Graph Engine</em>
      <br />
      Lindsay Kay
    </td>
    <td width="15%" align="right" class="tipsAPI">WebGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      41. <em>Features WebGL and Design Choices in SpiderGL</em>
      <br />
      Marco Di Benedetto, Fabio Ganovelli, and Francesco Banterle
    </td>
    <td width="15%" align="right" class="tipsAPI">WebGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      42. <em>Multimodal Interactive Simulations on the Web</em>
      <br />
      Tansel Halic, Woojin Ahn, and Suvranu De
    </td>
    <td width="15%" align="right" class="tipsAPI">WebGL</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      43. <em>A Subset Approach to Using OpenGL and OpenGL ES</em>
      <br />
      Jesse Barker and Alexandros Frantzis
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL<br />OpenGL ES</td>
  </tr> 

  <tr class="spaceUnder">
    <td>
      44. <em>The Build Syndrome</em>
      <br />
      Jochem van der Spek and Daniel Dekkers
    </td>
    <td width="15%" align="right" class="tipsAPI">OpenGL<br />OpenGL ES</td>
  </tr>

<!--

<tr class="spaceUnder">
  <td>
  x. <em>xxx</em>
  <br />
  xxx
  </td>
  <td width="15%" align="right" class="tipsAPI">OpenGL</td>
  <td width="15%" align="right" class="tipsAPI">OpenGL<br />WebGL<br />OpenGL ES</td>
  <td width="15%" align="right" class="tipsAPI">OpenGL<br />OpenGL ES</td>
</tr> 

-->

</table>

<hr />

<!-- full section descriptions -->
<dl id="full-toc">
  <dt>
    <span>I</span> Discovering
  </dt>
  <dd>
    <p>
      In this section, we discover many facets of OpenGL: teaching modern OpenGL in academia; using OpenGL on the web with WebGL; tessellation shaders in OpenGL 4.0; procedural textures; the safety critical variant, OpenGL SC; and multi-GPU OpenGL and CUDA interop.
    </p>
    <p>
      OpenGL enjoys widespread use in computer graphics courses around the world. Now-depreciated OpenGL features such as fixed-function lighting, immediate mode, and built-in transforms made the barrier to entry low. However, modern OpenGL has removed many of these features, resulting in a lean API that exposes the func- tionality of the underlying hardware. Academia has taken these changes in stride, updating their graphics courses to modern OpenGL. In Chapter 1, “Teaching Com- puter Graphics Starting With Shader-Based OpenGL,” Edward Angel discusses how an introductory computer graphics course can be taught using modern OpenGL. In Chapter 2, “Transitioning Students to Post-Deprecation OpenGL,” Mike Bailey presents C++ abstractions and GLSL naming conventions to bridge the gap between depreciated and modern OpenGL for use in course assignments.
    </p>
    <p>
      When we announced our call for authors for OpenGL Insights in May 2011, we included WebGL as a desired topic. Since then, WebGL has gained such traction that an entire book could easily be justified. In Chapter 3, “WebGL for OpenGL Developers,” Patrick Cozzi and Scott Hunter present WebGL for those who already know OpenGL. In the following chapter, “Porting Mobile Apps to WebGL,” Ashraf Samy Hegab shows the benefits, differences, and trade-offs of using WebGL for mo- bile applications. Several chapters in later sections continue our WebGL exploration.
    </p>
    <p>
      Christophe Riccio takes a rigorous look at communication between the OpenGL API and GLSL and different shader stages in Chapter 5, “The GLSL Shader Inter- faces.” He carefully examines using varying blocks; attribute, varying, and fragment output variable locations; linked and separated programs; using semantics in our designs; and more.
    </p>
    <p>
      Today, one of the differences between movie-quality rendering and real-time ren- dering is geometric complexity; movies generally have much higher geometric detail. To improve geometric detail in real-time rendering, tessellation can be done in hard- ware. Although this has been available on ATI cards since the ATI Radeon 8500 in 2001, tessellation shaders were recently standardized and made part of OpenGL 4.0. In Chapter 6, “An Introduction to Tessellation Shaders,” Philip Rideout and Dirk Van Gelder introduce the new fixed and programmable tessellation stages.
    </p>
    <p>
      As the gap between compute power and memory bandwidth continues to widen, procedural techniques become increasingly important. Small size is speed. Procedu- ral textures not only have trivial memory requirements, but can also have excellent visual quality, allowing for analytic derivatives and anisotropic antialiasing. Stefan Gustavson introduces procedural textures, including antialiasing and using Perlin and Worley noise in Chapter 7, “Procedural Textures in GLSL.” Best of all, he pro- vides GLSL noise functions for OpenGL, OpenGL ES, and WebGL.
    </p>
    <p>
      OpenGL SC, for safety critical, may be one of the lesser-known OpenGL vari- ants. In Chapter 8, “OpenGL SC Emulation Based on OpenGL and OpenGL ES,” Hwanyong Lee and Nakhoon Baek explain the motivation for OpenGL SC and de- scribe the benefits of implementing it based on other OpenGL variants, instead of creating custom drivers or a software implementation.
    </p>
    <p>
      In the past 15 years, consumer GPUs have transformed from dedicated fixed- function graphics processors to general-purpose massively-parallel processors. Tech- nologies like CUDA and OpenCL have emerged for developing general data-parallel algorithms on the GPU. There is, of course, a need for these general algorithms, like particle systems and physical simulation, to interop efficiently with OpenGL for rendering. In the final chapter of this section, “Mixing Graphics and Compute with Multiple GPUs,” Alina Alt reviews interoperability between CUDA and OpenGL and presents interoperability between multiple GPUs where one GPU is used for CUDA and another for OpenGL.
    </p>
  </dd>

  <dt>
    <span>II</span> Rendering Techniques
  </dt>
  <dd>
    <p>
      We can’t possibly imagine a book about OpenGL without rendering, and neither could the authors of this book.
    </p>
    <p>
      Anto ́nio Ramires Fernandes and Bruno Oliveira provide a use case for the new OpenGL 4 tessellation pipeline through terrain rendering in their chapter “GPU Tessellation: We Still Have a LOD of Terrain to Cover,” providing an entirely GPU- based method for continuous level of detail maintaining a high level of fidelity to the original mesh.
    </p>
    <p>
      S&eacute;bastien Hillaire brings us to a parallel universe where rendering is defined by lines in his chapter “Antialiased Volumetric Lines Using Shader-Based Extrusion.” He comes back on the line primitives exposed by OpenGL and their issues before bringing perspective to line rendering thanks to two approaches: one based on the vertex shader stage and one based on the geometry shader stage for perspective correct and antialiased lines.
    </p>
    <p>
      Stefan Gustavson leads us close to new borders through his chapter “2D Shape Rendering by Distance Fields,” allowing perfectly antialiased contours. He is pushing his concept to font rendering and distance field-based effects.
    </p>
    <p>
      Benjamin Encz analyses WebGL font rendering in his chapter “Efficient Text Rendering in WebGL” by describing canvas- and bitmap-based methods. He con- cludes his chapter with a performance analysis with both the frame rate and the memory footprint in mind.
    </p>
    <p>
      Dzmitry Malyshau discusses an approach inspired by Blender in his chapter “Lay- ered Textures Rendering Pipeline.” He aims at providing more flexibility to the ren- dering pipeline to handle complex object materials so that artists may express their creativity during the producing while maintaining real-time performance.
    </p>
    <p>
      Charles de Rousiers and Matt Pettineo present a method for “Depth of Field with Bokeh Rendering.” Their method, developed around OpenGL 4 hardware atomic counter, image load and store, and indirect draw, provides a level of performance for real-time application.
    </p>
    <p>
      Finally, Jochem van der Spek introduces a technique he calls “Shadow Proxies,” which provides, for appropriate scenarios, real-time soft shadows with color bleeding.
    </p>
  </dd>

  <dt>
    <span>III</span> Bending the Pipeline
  </dt>
  <dd>
    <p>
      Today GPUs are masters of performance, considering either high-end desktop GPUs or even mobile GPUs, which deliver an unbelievable amount of graphics rel- ative to the power consumption. The future of graphics raises a lot of question regarding how to scale performance, doing more with less. Based on research on petascale and exoscale supercomputers, we notice that such a scale of performance forces us to reconsider memory, bandwidth, and data movement. Challenges are ahead for GPU innovations. Under the name “bending the pipeline,” we include all ideas that push the graphics pipeline to explore alternative ways to feed the rendering pipeline.
    </p>
    <p>
      We start with two classic techniques. The first one, “Real-Time Physically-Based Deformation Using Transform Feedback,” presented by Muhammad Mobeen Mova- nia and Lin Feng, explores the OpenGL transform feedback for GPU-based physical simulation. The second technique, “Hierarchical Depth-Culling and Bounding-Box Management on GPU,” presented by Dzmitry Malyshau, presents a method based on the depth buffer and bounding boxes to discard invisible objects before the actual rendering even starts.
    </p>
    <p>
      Maybe shadow mapping is a way to bend the pipeline, but Daniel Ra ́kos certainly pushes it further in his chapter “Massive Number of Shadows with Layered Render- ing” with a rendering method allowing him to generate multiple shadow maps per draw call thanks to layered rendering.
    </p>
    <p>
      In their chapter “Efficient Layered Fragment Buffer Techniques,” Pyarelal Knowles, Geoff Leach, and Fabio Zambetta lead us to explore one of the most inter- esting innovations of OpenGL 4 hardware, image load store, and atomic operations, through an example of order-independent transparency with a special highlight of performance resulting from different approaches.
    </p>
    <p>
      One step further into innovation, Daniel Ra ́kos introduces “Programmable Ver- tex Pulling,” a radical change of perspective, where we don’t submit work to the GPU, but let the GPU query the work. No doubt this approach will evolve and gain a lot of importance in the years to come.
    </p>
    <p>
      If pushing the boundaries of today’s graphics requires a shift in paradigm, bring- ing new asset representations might be an answer. This is the direction of the work on Gigavoxels of Cyril Crassin and Simon Green. For their OpenGL Insights chapter “Octree-Based Sparse Voxelization Using the GPU,” they explain how a GPU may be efficiently used to build voxel-based representation.
    </p>
  </dd>

  <dt>
    <span>IV</span> Performance
  </dt>
  <dd>
    <p>
      When it comes to real-time graphics, performance is what defines the possible from the impossible; it is what sets the boundaries.
    </p>
    <p>
      A lack of performance might come from a lack of understanding of the platform we are working on. This may have a dramatic negative impact on the tile-based GPUs leading the OpenGL ES world. In his chapter, “Performance Tuning for Tile- Based Architectures,” Bruce Merry presents key tile-based GPU architecture features and how to take advantage of them. Jon McCaffrey follows this discussion in his chapter “Exploring Mobile vs. Desktop OpenGL Performance,” which shows the performance-scale differences between the mobile and desktop worlds.
    </p>
    <p>
      Performance is not only the concern of GPU architectures, it is also the direct result of how we write software. With GPUs whose performances increase at a faster rate than CPUs, we are more and more often CPU-bound, leaving us incapable to benefit from all the GPU power. Se ́bastien Hillaire, in his chapter “Improving Per- formance by Reducing Calls to the Drivers,” introduces some fundamental concepts to reduce CPU overhead with a legacy flavor.
    </p>
    <p>
      In his chapter “Indexing Multiple Vertex Arrays,” Arnaud Masserann comes back to one of the most fundamental elements for GPU performance: how we submit vertex array data to the GPU. He provides a directly applicable method to ensure that vertex indexing will be used even on assets not organized this way, like COLLADA geometry.
    </p>
    <p>
      Finally, sometimes we are left with no choice: to scale performance, we must scale the number of GPUs used for rendering. This is the topic of Shalini Venkataraman in her chapter “Multi-GPU Rendering on NVIDIA Quadro.” She explains how to efficiently use multiple GPUs for rendering and integrate their work to build the final image.
    </p>
  </dd>

  <dt>
    <span>V</span> Transfers
  </dt>
  <dd>
    <p>
      OpenGL applications transfer a lot of data. Data is transferred between machines, between disk and system memory, between system and video memory, between video memory and video memory, and so on. Optimizing these transfers improves perfor- mance. In this section, we look at optimizing asynchronous transfers between the CPU and GPU; compressing models for use with WebGL; compressing textures on the GPU for video creation; and an efficient geometry file format.
    </p>
    <p>
      Although general computations like particle systems are being pushed to the GPU, there is still a need to do many computations or IO on the CPU and then efficiently stream data to the GPU. In Chapter 28, “Asynchronous Buffer Transfers,” Ladislav Hrabcak and Arnaud Masserann share best practices for maximizing per- formance when using buffer objects to transfer data between the CPU and GPU in either direction. With detailed performance analysis, they cover direct memory access (DMA), buffer usage hints, implicit synchronization with draw calls, pinned memory, and multithreading. Shalini Venkataraman continues the asynchronous transfers discussion in the following chapter, “Fermi Asynchronous Texture Trans- fers,” where she discusses how the NVIDIA Fermi architecture allows transfer and rendering to occur at the same time when using multiple threads and OpenGL contexts.
    </p>
    <p>
      The discussion of transfers moves from within a system to across systems in Chapter 30, “WebGL Models: End-to-End.” Won Chun presents the techniques, including a detailed analysis, used in Google Body to compress and transfer mod- els to a web browser for rendering with WebGL. Continuing on the compression theme, Brano Kemen demonstrates real-time image compression on the GPU in Chapter 31, “In-Game Video Capture with Real-Time Texture Compression.” He applies his method to video compression using a DXT fixed-rate compression format to reduce bandwidth consumption, and he explores various decoloration methods to enhance image compression quality.
    </p>
    <p>
      In graphics, content is king. A smooth content-creation pipeline empowers artists, and a format that requires minimal runtime processing improves load times. In the last chapter of this section, “An OpenGL Friendly Geometry File Format and its Maya Exporter,” Adrien Herubel and Venceslas Biri present the Drone format, a binary geometry file format suitable for use with OpenGL.
    </p>
  </dd>

  <dt>
    <span>VI</span> Debugging and Profiling
  </dt>
  <dd>
    <p>
      We probably often underestimate how powerful the OpenGL API can be. However, programming is less about the result than the process to reach this result. The most impressive rendering is nothing but the end of a path that is, in a large part, debug- ging and profiling. Unfortunately, OpenGL doesn’t have a great reputation on that side. Who really enjoys using glGetError?
    </p>
    <p>
      This part of the OpenGL experience is now history since the release at SIG- GRAPH 2010 of the GL ARB debug ouput extension that revolutionizes every day of an OpenGL programmer’s life. This revolution is captured by Anto ́nio Ramires and Bruno Oliveira in their chapter “ARB debug output: OpenGL’s Solutions for Desperate Developers,” which shows every aspect of this extension, how to break the program when an OpenGL error occurs, and even opens on interesting debugging perspectives.
    </p>
    <p>
      Profiling knew an earlier take-off in the world of OpenGL programming thanks to the release of GL EXT timer query in 2006, then standardized within OpenGL 3.3. Thanks to Christopher Lux and his chapter, “The OpenGL Timer Query,” this primitive of OpenGL profiling won’t hide any secrets any longer.
    </p>
    <p>
      There are two kinds of profiler: the built-in and the external tools, which pro- vide two different approaches to picture profiling. On one side, a profiler tightly connected to application designs and specific use-cases, on other side more generic tools that can embrace all sorts of scenarios and software. The first approach is per- fectly reflected by Lionel Fuentes in his chapter “A Real-Time Profiling Tool,” which deals with how a built-in real-time profiler can help the game programmer and also the artist creating game assets. Chris Dirks and Omar A. Rodriguez expose the sec- ond approach through their chapter “Browser Graphics Analysis and Optimizations,” which discuss the utilization of Intel GPA to study WebGL performance.
    </p>
    <p>
      Finally, Aleksandar Dimitrijevic ́ offers us two innovative profiling chapters, first introducing us to GPU P-States in his chapter “Performance State Tracking,” where he calls our attention to how GPUs reach full speed and how this may affect our performance measurements. He backs his discussion with AMD and NVIDIA pro- prietary libraries. In his second chapter, he deals with the problem of GPU memory limits. OpenGL doesn’t provide functionalities to determine the actual memory us- age, but proprietary extensions provide the required information, and Dimitrijevic ́ helps us to go through them in his chapter “Monitoring Graphics Memory Usage.”
    </p>
  </dd>

  <dt>
    <span>VII</span> Software Design
  </dt>
  <dd>
    <p>
      Developers work with OpenGL at many levels of the software stack. Some developers create OpenGL implementations by writing drivers or, as we will see, using another graphics API; other developers create middleware or engines that simplify the use of OpenGL and raise the level of abstraction; and perhaps the majority of OpenGL developers create actual applications, whether by directly calling OpenGL or by using OpenGL-based engines. In this section, we look at software design at each layer of this stack. We consider implementing OpenGL ES 2.0, engines and applications built on WebGL, making legacy OpenGL code modern, and building cross-platform OpenGL applications.
    </p>
    <p>
      ANGLE, or the Almost Native Graphics Layer Engine, provides an OpenGL ES 2.0 implementation using Direct3D 9. It is used as the default WebGL backend for Chrome and Firefox on Windows. Implementing ANGLE is not nearly as simple as converting OpenGL calls to Direct3D calls; the differences in capabilities of the APIs need to be taken into account. In Chapter 39, “The ANGLE Project: Imple- menting OpenGL ES 2.0 on Direct3D,” Daniel Koch and Nicolas Capens discuss the implementation challenges in ANGLE, provide performance results, and suggest recommended practices.
    </p>
    <p>
      Given how low-level WebGL is compared to other web APIs, it was clear from its start that there would be demand for higher-level 3D engines built on WebGL. Here, we look at two such engines. SceneJS is an open-source 3D engine, based on a scene graph optimized for rendering large numbers of individually pickable and articulated objects. In Chapter 40, “SceneJS: A WebGL-Based Scene Graph Engine,” Lindsay Kay presents SceneJS’ architecture and how it makes efficient use of JavaScript and WebGL.
    </p>
    <p>
      SpiderGL is another 3D graphics library that uses WebGL. Instead of providing higher-level constructs like a scene graph, SpiderGL provides utilities, data struc- tures, and algorithms to simplify WebGL development but still allows the use of other WebGL code in the same application. In Chapter 41, “Features and Design Choices in SpiderGL,” Marco Di Benedetto, Fabio Ganovelli, and Francesco Ban- terle discuss some design and implementation decisions in SpiderGL including its model representation and allowing seamless interoperability with naive WebGL calls.
    </p>
    <p>
      WebGL is enabling a whole new class of applications. In Chapter 42, “Multi- modal Interactive Simulations on the Web,” Tansel Halic, Woojin Ahn, and Suvranu De present a framework for visualization, simulation, and hardware integration for multimodal interactive simulations using WebGL. Think practicing surgical proce- dures using a web browser!
    </p>
    <p>
      Maintaining legacy and modern OpenGL code in the same code base can prove challenging. Jesse Barker and Alexandros Frantzis share their experiences in Chap- ter 43, “A Subset Approach to Using OpenGL and OpenGL ES.” They suggest ways to move to a single modern code base written against both OpenGL and OpenGL ES.
    </p>
    <p>
      In “The Build Syndrome,” the final chapter of this section and of the book, Jochem van der Spek and Daniel Dekkers discuss in detail building cross-platform OpenGL applications with C++/Objective-C and CMake.
    </p>
  </dd>
</dl>

</body>    
</html>
